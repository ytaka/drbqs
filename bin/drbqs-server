#!/usr/bin/env ruby

require 'drbqs'
require 'optparse'

Version = '0.0.12'

help_message =<<HELP
Usage: #{File.basename(__FILE__)} <definition.rb> [other files ...] [options ...]
       #{File.basename(__FILE__)} <definition.rb> [other files ...] [options ...] -- [server options ...]
Start DRbQS server of definition files.

HELP

options = {
  :log_file => STDOUT,
  :command_type => :server_start,
  :acl => DRbQS::Config.get_acl_file
}

test_opts = {}
execute_node_number = nil

command_argv, server_argv = DRbQS::Manage.split_arguments(ARGV)

begin
  OptionParser.new(help_message) do |opt|
    opt.on('-p PORT', '--port', Integer, 'Set the port number of server.') do |v|
      options[:port] = v
    end
    opt.on('--acl FILE', String, 'Set a file to define ACL.') do |v|
      options[:acl] = v
    end
    opt.on('--log-file STR', String, "Set the path of log file. If this options is not set, use STDOUT.") do |v|
      options[:log_file] = v
    end
    opt.on('--log-level LEVEL', String,
           "Set the log level. The value accepts 'fatal', 'error', 'warn', 'info', and 'debug'. The default is 'error'.") do |v|
      if /^(fatal)|(error)|(warn)|(info)|(debug)$/i =~ v
        options[:log_level] = eval("Logger::#{v.upcase}")
      else
        raise "Invalid log level."
      end
    end
    opt.on('--file-directory DIR', String, 'Set the file archive directory.') do |v|
      options[:file_directory] = v
    end
    opt.on('--scp-user USER', String, 'Set the user of scp destination.') do |v|
      options[:scp_user] = v
    end
    opt.on('--scp-host HOST', String, 'Set the host of scp destination.') do |v|
      options[:scp_host] = v
    end
    opt.on('--profile', 'Use profile for test exec.') do |v|
      test_opts[:profile] = true
    end
    opt.on('--debug', 'Set $DEBUG true.') do |v|
      $DEBUG = true
    end
    opt.on('--test STR', String, 'Execute test.') do |v|
      options[:command_type] = "test_#{v}"
    end
    opt.on('--execute-node NUM', Integer, 'Execute nodes.') do |v|
      execute_node_number = v
    end
    opt.parse!(command_argv)
  end
rescue OptionParser::InvalidOption
  $stderr.print <<MES
error: Invalid Option
#{help_message}
MES
  exit(2)
rescue OptionParser::InvalidArgument
  $stderr.print <<MES
error: Invalid Argument
#{help_message}
MES
  exit(2)
end

if command_argv.size == 0 || !File.exist?(command_argv[0])
  raise "Invalid arguments. Please refer '#{File.basename(__FILE__)} -h'."
end

command_argv.each do |path|
  puts "load #{path}"
  load path
end

WAIT_SERVER_TIME = 0.3

DRbQS.parse_option(server_argv)
case options[:command_type]
when /^test/
  s = options[:command_type].split('_')[1].split(',')
  type = s[0].intern
  DRbQS.test_server(options, type, s[1..-1], test_opts)
else
  if execute_node_number
    fork do
      DRbQS.start_server(options)
    end
    uri = "druby://:#{options[:port] || DRbQS::ROOT_DEFAULT_PORT}"
    manage = DRbQS::Manage.new
    begin
      sleep(WAIT_SERVER_TIME)
    end while !manage.get_status(uri)
    node_log_file = nil
    unless IO === options[:log_file]
      node_log_file = FileName.create(options[:log_file], :add => :always, :position => :middle, :delimiter => '', :format => "_node_%02d")
    end
    exec_node = DRbQS::ExecuteNode.new(uri, node_log_file, options[:log_level])
    exec_node.execute(execute_node_number)
    exec_node.wait
  else
    DRbQS.start_server(options)
  end
end
