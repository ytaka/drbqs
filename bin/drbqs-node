#!/usr/bin/env ruby

require 'drbqs'
require 'optparse'

Version = '0.0.1'

help_message =<<HELP
Usage: #{File.basename(__FILE__)} [<uri>] [<process_number>] [options ...]
Start DRbQS nodes connecting to <uri>.

HELP

LOG_PREFIX_DEFAULT = 'drbqs_node'
LOG_LEVEL_DEFAULT = Logger::ERROR

options = {
  :log_prefix => LOG_PREFIX_DEFAULT,
  :log_level => LOG_LEVEL_DEFAULT,
  :load => []
}

begin
  OptionParser.new(help_message) do |opt|
    opt.on('-l', '--load FILE', String, 'Add a file to load.') do |v|
      options[:load] << File.expand_path(v)
    end
    opt.on('--log-prefix STR', String, "Set the prefix of log files. The default is '#{LOG_PREFIX_DEFAULT}'.") do |v|
      options[:log_prefix] = v
    end
    opt.on('--log-level LEVEL', String,
           "Set the log level. The value accepts 'fatal', 'error', 'warn', 'info', and 'debug'. The default is 'error'.") do |v|
      if /^(fatal)|(error)|(warn)|(info)|(debug)$/i =~ v
        options[:log_level] = eval("Logger::#{v.upcase}")
      else
        raise "Invalid log level."
      end
    end
    opt.on('--log-stdout', 'Use stdout for outputting logs. This option cancels --log-prefix.') do |v|
      options[:log_prefix] = nil
    end
    opt.on('--debug', 'Set $DEBUG true.') do |v|
      $DEBUG = true
    end
    opt.parse!(ARGV)
  end
rescue OptionParser::InvalidOption
  $stderr.print <<MES
error: Invalid Option
#{help_message}
MES
  exit(2)
rescue OptionParser::InvalidArgument
  $stderr.print <<MES
error: Invalid Argument
#{help_message}
MES
  exit(2)
end

if ARGV.size > 2
  raise "Too many arguments. Please refer '#{File.basename(__FILE__)} -h'."
end

process_num = 1
uri = "druby://localhost:#{DRbQS::ROOT_DEFAULT_PORT}"

ARGV.each do |arg|
  if /^\d+$/ =~ arg
    process_num = arg.to_i
  else
    uri = arg
  end
end

options[:load].each do |v|
  puts "load #{v}"
  load v
end

puts "Connect to #{uri}"
puts "Execute #{process_num} processes"

if options[:log_prefix]
  if /\/$/ =~ options[:log_prefix]
    options[:log_prefix] += 'out'
  end
end

process_num.times do |i|
  fork do
    if options[:log_prefix]
      logfile = FileName.create(options[:log_prefix], :position => :suffix, :type => :time,
                                :add => :always, :directory => :parent,
                                :format => lambda { |t| t.strftime("%Y%m%d_%H%M_#{Process.pid}.log") })
    else
      logfile = STDOUT
    end
    client = DRbQS::Client.new(uri, :log_level => options[:log_level], :log_file => logfile)
    client.connect
    client.calculate
  end
end

Process.waitall
