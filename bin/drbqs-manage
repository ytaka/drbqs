#!/usr/bin/env ruby

$LOAD_PATH.unshift(File.expand_path(File.dirname(__FILE__) + '/../lib'))
require 'drbqs/utility/command_line'

help_message =<<HELP
Usage: #{File.basename(__FILE__)} <command> [arguments ...]
Manage DRbQS server by sending messages.
<command> is 'exit-signal', 'exit-after-task', or 'initialize'.

HELP

command = ARGV[0]
argv = ARGV

begin
  OptionParser.new(help_message) do |opt|
    opt.on('--debug', 'Set $DEBUG true.') do |v|
      $DEBUG = true
    end
    opt.parse!(argv)
  end
rescue OptionParser::InvalidOption
  $stderr.print <<MES
error: Invalid Option
#{help_message}
MES
  exit(2)
rescue OptionParser::InvalidArgument
  $stderr.print <<MES
error: Invalid Argument
#{help_message}
MES
  exit(2)
end

manage = DRbQS::Manage.new

case command
when 'exit-signal'
  DRbQS::CommandLineArgument.check_argument_size(argv, :==, 2)
  uri = argv[1]
  manage.send_exit_signal(uri)
when 'exit-after-task'
  DRbQS::CommandLineArgument.check_argument_size(argv, :==, 3)
  uri = argv[1]
  node_id = argv[2].to_i
  manage.send_node_exit_after_task(uri, node_id)
when 'status'
  DRbQS::CommandLineArgument.check_argument_size(argv, :==, 2)
  uri = argv[1]
  if status = manage.get_status(uri)
    $stdout.puts status
  end
when 'initialize'
  DRbQS::CommandLineArgument.check_argument_size(argv, :==, 1)
  manage.create_config
when 'process'
  DRbQS::CommandLineArgument.check_argument_size(argv, :==, 1)
  list = manage.list_process
  $stdout.puts "Server"
  list[:server].each do |uri, data|
    $stdout.puts "#{uri}"
    data.each do |k, v|
      $stdout.puts sprintf("  %-10s  %s", k, v)
    end
  end
  $stdout.puts "\nNode"
  list[:node].each do |pid, data|
    $stdout.puts "#{pid}"
    data.each do |k, v|
      $stdout.puts sprintf("  %-10s  %s", k, v)
    end
  end
else
  raise "Invalid command: #{command}"
end
